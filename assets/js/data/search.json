[ { "title": "MySQL 基础", "url": "/posts/MySQL-%E5%9F%BA%E7%A1%80/", "categories": "mysql", "tags": "mysql", "date": "2022-03-06 15:52:00 +0800", "snippet": "##" }, { "title": "Redis 面试题", "url": "/posts/Redis-%E9%9D%A2%E8%AF%95%E9%A2%98/", "categories": "redis", "tags": "redis", "date": "2022-03-06 02:05:00 +0800", "snippet": "##" }, { "title": "Go 面试题", "url": "/posts/Go-%E9%9D%A2%E8%AF%95%E9%A2%98/", "categories": "go", "tags": "go", "date": "2022-03-06 02:04:00 +0800", "snippet": "" }, { "title": "Redis 设计", "url": "/posts/Redis-%E8%AE%BE%E8%AE%A1/", "categories": "redis", "tags": "redis", "date": "2022-03-06 02:03:00 +0800", "snippet": "数据结构SDSListMapSkipListInSetZipListObject单机数据库数据库RDB 持久化AOF 持久化事件客户端服务器多机数据库复制哨兵集群独立功能发布、订阅事务Lua 脚本排序二进制位数组慢查询日志监视器" }, { "title": "Go 设计", "url": "/posts/Go-%E8%AE%BE%E8%AE%A1/", "categories": "go", "tags": "go", "date": "2022-03-06 01:46:00 +0800", "snippet": "Go 编译原理数据类型字符串数组切片哈希表语言基础函数调用接口反射关键字for、rangeselectdeferpanic、recovermake、new并发编程Context同步原语、锁定时器Channel调度器网络轮询器系统监控内存管理内存分配器垃圾收集器栈内存管理元编程插件系统代码生成标准库JSONHTTP数据库" }, { "title": "Go 基础", "url": "/posts/Go-%E5%9F%BA%E7%A1%80/", "categories": "go", "tags": "go", "date": "2022-03-05 10:09:00 +0800", "snippet": "Go 主要特征 自动立即回收。 更丰富的内置类型。 函数多返回值。 错误处理。 匿名函数和闭包。 类型和接口。 并发编程。 反射。 语言交互性Go 命名命名规则 首字符可以是任意的Unicode字符或者下划线 剩余字符可以是Unicode字符、下划线、数字 字符长度不限关键字break default func interface selectcase defer go map structchan else goto package switchconst fallthrough if range typecontinue for import return var保留字Constants: true false iota nilTypes: int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune string errorFunctions: make len cap new append copy close delete complex real imag panic recoverGo语言声明var（声明变量）, const（声明常量）, type（声明类型） ,func（声明函数）内置类型值类型boolint, int8, int16, int32(rune), int64uint, uint8(byte), uint16, uint32, uint64float32, float64complex64, complex128stringarraystruct引用类型pointerslicemapfunctionchannel接口类型interface内置函数real -- 返回complex的实部 imag -- 返回complex的虚部append -- 用来追加元素到数组、slice中,返回修改后的数组、slicecopy -- 用于复制和连接slice，返回复制的数目delete -- 从map中删除key对应的valueclose -- 主要用来关闭channelmake -- 用来分配内存，返回Type本身(只能应用于slice, map, channel)new -- 用来分配内存，主要用来分配值类型，比如int、struct。返回指向Type的指针len -- 来求长度，比如string、array、slice、map、channel ，返回长度cap -- capacity是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map）panic -- 停止常规的goroutine （panic和recover：用来做错误处理）recover -- 允许程序定义goroutine的panic动作print、println -- 底层打印函数，在部署环境中建议使用 fmt 包内置接口type error interface { Error() String}init 、main 函数init 函数 init函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等 每个包可以拥有多个init函数 包的每个源文件也可以拥有多个init函数 同一个包中多个init函数的执行顺序go语言没有明确的定义(说明) 不同包的init函数按照包导入的依赖关系决定该初始化函数的执行顺序 init函数不能被其他函数调用，而是在main函数执行之前，自动被调用 main 函数Go语言程序的默认入口函数(主函数)init 与 main异同 相同点： 两个函数在定义时不能有任何的参数和返回值，且Go程序自动调用。 不同点： init可以应用于任意包中，且可以重复定义多个。 main函数只能用于main包中，且只能定义一个。 运算符算数运算符 运算符 描述 + 相加 - 相减 * 相乘 / 相除 % 求余 关系运算符 运算符 描述 == 检查两个值是否相等 != 检查两个值是否不相等 &amp;gt; 检查左边值是否大于右边值 &amp;gt;= 检查左边值是否大于等于右边值 &amp;lt; 检查左边值是否小于右边值 &amp;lt;= 检查左边值是否小于等于右边值 逻辑运算符 运算符 描述 &amp;amp;&amp;amp; 逻辑 AND 运算符 ll 逻辑 OR 运算符 ! 逻辑 NOT 运算符 位运算符 运算符 描述 &amp;amp; 参与运算的两数各对应的二进位相与 l 参与运算的两数各对应的二进位相或 ^ 参与运算的两数各对应的二进位相异或 « 左移n位 » 右移n位 &amp;amp;^ 位清空 变量、常量变量 标准声明 var name stringvar age intvar isOk bool 批量声明 var ( a string b int c bool d float32) 变量初始化 Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值：整型和浮点型变量的默认值为0。 字符串变量的默认值为空字符串。 布尔型变量默认为false。 切片、函数、指针变量的默认为nil。 声明时初始化 var name string = &quot;pprof.cn&quot;var sex int = 1var name, sex string= &quot;pprof.cn&quot;, &quot;boy&quot; 类型推导 var name = &quot;pprof.cn&quot;var sex = 1 短变量声明 在函数内部，可以使用更简略的 := 方式声明并初始化变量。 package main var m = 100 func main() { m := 200 // 此处声明局部变量m} 匿名变量 匿名变量用一个下划线_表示。 匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。 常量常量在定义的时候必须赋值。const pi = 3.1415const e = 2.7182const ( pi = 3.1415 e = 2.7182)const ( n1 = 100 n2 n3) // n1、n2、n3的值都是100 iota const ( n1 = iota //0 n2 //1 n3 //2 n4 //3 ) const ( n1 = iota //0 n2 //1 _ n4 //3) const ( n1 = iota //0 n2 = 100 //100 n3 = iota //2 n4 //3)const n5 = iota //0 const ( _ = iota KB = 1 &amp;lt;&amp;lt; (10 * iota) MB = 1 &amp;lt;&amp;lt; (10 * iota) GB = 1 &amp;lt;&amp;lt; (10 * iota) TB = 1 &amp;lt;&amp;lt; (10 * iota) PB = 1 &amp;lt;&amp;lt; (10 * iota)) const ( a, b = iota + 1, iota + 2 //1,2 c, d //2,3 e, f //3,4) StringGo 语言里的字符串的内部实现使用UTF-8编码。可以在Go语言的源码中直接添加非ASCII码字符s1 := &quot;hello&quot;s2 := &quot;你好&quot; 多行字符串 s1 := `第一行第二行第三行` byte、rune byte 类型，代表了 ASCII 码的一个字符。 rune 类型，代表一个 UTF-8 字符。 // 遍历字符串func traversalString() { s := &quot;pprof.cn博客&quot; for i := 0; i &amp;lt; len(s); i++ { //byte fmt.Printf(&quot;%v(%c) &quot;, s[i], s[i]) } fmt.Println() for _, r := range s { //rune fmt.Printf(&quot;%v(%c) &quot;, r, r) } fmt.Println()}// 112(p) 112(p) 114(r) 111(o) 102(f) 46(.) 99(c) 110(n) 229(å) 141() 154() 229(å) 174(®) 162(¢)// 112(p) 112(p) 114(r) 111(o) 102(f) 46(.) 99(c) 110(n) 21338(博) 23458(客) // 修改字符串func changeString() { s1 := &quot;hello&quot; byteS1 := []byte(s1) byteS1[0] = &#39;H&#39; fmt.Println(string(byteS1)) // Hello s2 := &quot;博客&quot; runeS2 := []rune(s2) runeS2[0] = &#39;狗&#39; fmt.Println(string(runeS2)) // 狗客} Array 数组：是同一种数据类型的固定长度的序列。 数组定义：数组长度必须是常量，且是类型的组成部分。一旦定义，长度不能变。 // 全局var arr0 [5]int = [5]int{1, 2, 3}var arr1 = [5]int{1, 2, 3, 4, 5}var arr2 = [...]int{1, 2, 3, 4, 5, 6}var str = [5]string{3: &quot;hello world&quot;, 4: &quot;tom&quot;}// 局部a := [3]int{1, 2} // 未初始化元素值为 0。b := [...]int{1, 2, 3, 4} // 通过初始化值确定数组长度。c := [5]int{2: 100, 4: 200} // 使用索引号初始化元素。d := [...]struct { name string age uint8}{ {&quot;user1&quot;, 10}, // 可省略元素类型。 {&quot;user2&quot;, 20}, // 别忘了最后一行的逗号。} 数组可以通过下标进行访问，下标是从0开始，最后一个元素下标是：len-1。 arr := [4]int{1, 2, 3, 4}for k, v := range arr { // k: index, v: value} 访问越界，如果下标在数组合法范围之外，则触发访问越界，会panic。 数组是值类型，赋值和传参会复制整个数组，而不是指针。因此改变副本的值，不会改变本身的值。值拷贝行为会造成性能问题，通常会建议使用 slice，或数组指针。 内置函数 len 和 cap 都返回数组长度 (元素数量)。 支持 “==”、”!=” 操作符，因为内存总是被初始化过的。 指针数组 [n]*T，数组指针 *[n]T。 Slice 创建切片 var s1 []ints2 := []int{}s5 := []int{1, 2, 3} 从数组切片 arr := [5]int{1, 2, 3, 4, 5}var s6 = arr[1:4] make 创建切片 var slice []type = make([]type, len)slice := make([]type, len)slice := make([]type, len, cap) 切片操作 操作 含义 s[n] 数组或切片索引为n的项 s[:] 从数组或切片的索引 0 至 len(s)-1 处获得的切片 s[low:] 从数组或切片的索引 low 至 len(s)-1 处获得的切片 s[:high] 从数组或切片的索引 0 至 high-1 处获得的切片 s[low:high] 从数组或切片的索引 low 至 high-1 处获得的切片 s[low:high:max] 从数组或切片的索引 low 至 high-1 处获得的切片，cap=max-low len(s) 数组或切片的长度 cap(s) 数组或切片的容量 超出原 slice.cap 限制， 通常以 2 倍容量重新分配底层数组。 MapStruct" }, { "title": "Redis 基础", "url": "/posts/Redis-%E5%9F%BA%E7%A1%80/", "categories": "redis", "tags": "redis", "date": "2022-03-05 10:08:00 +0800", "snippet": "数据类型StringHashListSetSorted SetHyperLogLogBitmapGeoStream附加功能数据库自动过期流水线、事务Lua 脚本持久化发布、订阅模块多机功能复制哨兵集群" }, { "title": "Jekyll 使用", "url": "/posts/Jekyll-%E4%BD%BF%E7%94%A8/", "categories": "other, blog", "tags": "Jekyll", "date": "2022-03-05 02:19:00 +0800", "snippet": "New PostText and Typography" } ]
